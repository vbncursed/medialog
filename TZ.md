# Техническое задание (ТЗ)

## Web-сервис учёта просмотренного/прочитанного контента (MediaLog)

## 1. Общие сведения

**Наименование:** MediaLog — web-сервис учёта фильмов/сериалов/книг.
**Тип:** Веб-приложение (браузер) + серверная часть на микросервисной архитектуре.
**Клиентские платформы:** iPhone/MacBook (Safari/Chrome).
**Серверные платформы:** Linux, контейнеризация Docker.
**Ограничения:** нативные приложения iOS/macOS не разрабатываются.

---

## 2. Цели и назначение

### 2.1 Цели

* Учёт просмотренного/прочитанного: статусы, оценки, отзывы, теги, даты.
* Импорт истории из **Letterboxd** и **Goodreads**.
* Автоподтягивание постеров/обложек и метаданных.
* Публичные страницы/подборки по ссылке + “Year in Review”.

### 2.2 Назначение

Система предназначена для личного использования (и опционально — публичного просмотра выбранных подборок).

---

## 3. Характеристика объектов автоматизации

* **Контент (Media):** фильм/сериал/книга (метаданные, постер/обложка, внешние ID).
* **Запись пользователя (Entry):** статус, оценка, теги, заметка/отзыв, даты.
* **Импорт (Import Job):** загруженный файл, прогресс, ошибки, дедупликация.
* **События и фоновые задачи:** обработка импортов, обогащение метаданных, пересчёт статистики.

---

## 4. Требования к системе

# 4.1 Функциональные требования

## 4.1.1 Роли

* **Гость:** доступ к публичным страницам пользователей (если включено).
* **Пользователь:** управление библиотекой, импорт, статистика, настройки приватности.
* **Администратор (опционально):** доступ к метрикам/логам, лимитам и мониторингу очередей.

## 4.1.2 Авторизация и сессии

**Функции:** регистрация, вход, refresh, выход, (опц.) выход со всех устройств.
**Требования:**

* Пароль хранится в виде безопасного хэша.
* Access token (JWT) короткий TTL; refresh — контролируется сервером.
* Ограничение попыток входа (rate limit).

## 4.1.3 Библиотека пользователя (ядро)

**Типы:** movie / tv / book
**Статусы:** planned / in_progress / done
**Операции:**

* Добавление записи вручную (через поиск по контенту).
* Изменение статуса, оценки (0–10), заметки/отзыва, тегов, дат.
* Удаление записи.
* Списки с фильтрацией: тип/статус/теги/даты/рейтинг, сортировка, пагинация.

## 4.1.4 Поиск и карточки контента

* Поиск по названию (и при наличии — по внешним ID).
* Карточка: название, год, жанры, постер/обложка, источник/ID.

## 4.1.5 Импорт: Letterboxd

* Загрузка файла экспорта (CSV/ZIP — поддерживаемые форматы фиксируются в документации).
* Создание **Import Job** и запуск фоновой обработки.
* Просмотр прогресса: total/processed/errors.
* Дедупликация (повторный импорт не создаёт дубликатов).

## 4.1.6 Импорт: Goodreads

* Загрузка CSV экспорта.
* Маппинг shelf → статус:

  * read → done
  * currently-reading → in_progress
  * to-read → planned
* Перенос оценок/дат (если присутствуют).
* Прогресс/дедуп как в 4.1.5.

## 4.1.7 Публичные страницы и “Year in Review”

* Настройка приватности: публичный профиль включён/выключен.
* Публичная страница: последние записи, топ-подборки.
* Статистика: по месяцам/году, средняя оценка, топ-жанры/теги.
* Share-ссылка на “итоги года”.

## 4.1.8 Настройки

* Приватность профиля.
* Настройки отображения (сортировки по умолчанию и т.п.).
* Управление активными сессиями (опционально).

---

# 4.2 Требования к интерфейсу (UI/UX)

**Frontend:** Next.js (React) + Ant Design.
**Экраны:**

1. Login/Register
2. Dashboard (краткая статистика)
3. Library (плитка/таблица + фильтры)
4. Entry Edit (статус/оценка/теги/заметка/даты)
5. Import (загрузка + список jobs + прогресс)
6. Stats / Year in Review
7. Settings
8. Public profile (страницы по ссылке)

**Требования:** адаптивность, быстрые фильтры, skeleton loaders, единый дизайн AntD.

---

# 4.3 Архитектура и состав компонентов

## 4.3.1 Сервисы и инфраструктура

* **frontend (Next.js + AntD)**
* **api-gateway / BFF (Go)** — внешний REST API для фронта, агрегация данных
* **auth-service (Go, gRPC)** — пользователи, токены, сессии
* **library-service (Go, gRPC)** — записи пользователя (Entry)
* **metadata-service (Go, gRPC)** — поиск/метаданные/постеры/обложки, кэш
* **import-service (Go, gRPC)** — приём файлов импорта, управление Import Job
* **import-worker (Go)** — обработка очередей импорта (может быть отдельным контейнером)
* **PostgreSQL** — постоянное хранилище (логическое разделение по сервисам: отдельные БД или схемы)
* **Redis** — кэш метаданных, refresh-сессии/ключи безопасности, rate limiting, быстрый прогресс импорта
* **RabbitMQ** — брокер сообщений для асинхронных процессов (импорт, обогащение метаданных, пересчёт статистики)

## 4.3.2 Протоколы взаимодействия

* **Frontend ↔ BFF:** REST/JSON (HTTP)
* **BFF ↔ сервисы:** gRPC
* **Фоновые процессы:** RabbitMQ (events/queues), сервисы потребляют сообщения и вызывают друг друга по gRPC

## 4.3.3 Асинхронная модель (RabbitMQ)

**Общие требования:**

* Все потребители используют подтверждения (ack).
* Поддерживаются retry-очереди и **DLQ** (dead letter queue).
* Обработчики сообщений обязаны быть **идемпотентными** (повторная доставка не создаёт дубликатов).

**События/топики (пример):**

* `import.job.started`, `import.row.parsed`, `import.job.finished`
* `metadata.fetch.requested`, `metadata.updated`
* `library.entry.changed`
* `stats.recalc.requested`, `stats.updated` (если вводится stats-сервис)

**Очереди (пример):**

* `q.import.rows` + `q.import.rows.dlq`
* `q.metadata.fetch` + `q.metadata.fetch.dlq`
* `q.stats.recalc` + `q.stats.recalc.dlq` (опционально)

---

# 4.4 Требования к данным (БД)

## 4.4.1 Основные сущности

**auth-service:**

* users (id, email, pass_hash, created_at, …)
* sessions (session_id, user_id, expires_at, user_agent/ip, …) — допускается хранить в Redis

**library-service:**

* entries (entry_id, user_id, media_id, type, status, rating, review, started_at, finished_at, created_at, updated_at)
* entry_tags (entry_id, tag)

**metadata-service:**

* media (media_id, type, title, year, genres, poster_url/cover_url, updated_at)
* external_ids (media_id, source, external_id)

**import-service:**

* import_jobs (job_id, user_id, source, state, total, processed, errors, created_at, updated_at)
* import_rows (job_id, row_no, row_hash, state, error_text) — опционально

## 4.4.2 Индексы/ограничения

* Индексы: user_id, type, status, finished_at, rating.
* Уникальность/дедуп: (user_id, source, row_hash) или (user_id, media_id, finished_at) в зависимости от логики.
* Миграции обязательны.

---

# 4.5 Интеграции

* **Метаданные фильмов/сериалов:** внешний каталог (через metadata-service).
* **Метаданные книг:** внешний источник (ISBN/поиск) + covers.
* **Импорт:** пользовательский файл экспорта (CSV/ZIP), без прямой авторизации в сторонних сервисах.

---

# 4.6 Надёжность

* Перезапуск сервисов не приводит к потере задач:

  * Import Job хранится в Postgres,
  * задачи обработки доставляются через RabbitMQ,
  * при сбое задача попадает в retry/DLQ.
* Идемпотентность:

  * Upsert Entry в library-service,
  * обработка import.row.* не создаёт дубликаты.
* Регламент бэкапов Postgres (для прод окружения).

---

# 4.7 Безопасность

* HTTPS в prod.
* Хранение паролей только в виде хэшей.
* Токены/сессии: refresh контролируется сервером (Redis/БД).
* CORS, CSRF-модель (если refresh в cookie), валидация входных данных.
* Rate limiting: логин/регистрация/импорт.

---

# 4.8 Производительность

* Пагинация обязательна на списках.
* Кэширование метаданных (Redis) с TTL.
* Импорт выполняется асинхронно, UI получает прогресс без блокировки.
* Цель MVP: импорт до ~10k строк в фоне с отображением прогресса.

---

# 4.9 Наблюдаемость

* Структурированные логи (JSON) + корреляция request_id/trace_id.
* Метрики:

  * latency/RPS/errors по BFF и сервисам,
  * cache hit ratio (metadata),
  * очереди RabbitMQ: depth/consumer lag/DLQ count,
  * импорт: jobs в статусах, среднее время.
* Трейсинг (опционально, OpenTelemetry).

---

# 4.10 Развёртывание

* docker-compose: frontend, BFF, сервисы, postgres, redis, rabbitmq.
* Окружения dev/stage/prod через переменные окружения.
* CI: линтеры, тесты, сборка образов.

---

## 5. Состав и содержание работ

1. Проектирование: ER-модель, контракты gRPC, REST API BFF, модель событий RabbitMQ.
2. Инфраструктура: docker-compose, миграции, общие библиотеки.
3. Auth-service + интеграция с BFF.
4. Library-service (CRUD + фильтры + индексы).
5. Metadata-service (поиск/карточки + Redis-кэш).
6. Импорт: import-service + import-worker + очереди RabbitMQ + прогресс.
7. Frontend: экраны, импорты, библиотека, публичные страницы.
8. Статистика/Year in Review.
9. Тестирование и стабилизация, документация.

---

## 6. Порядок разработки (этапы)

**Этап 1 (MVP):** Auth + Library + Metadata + базовый UI.
**Этап 2:** Импорт (Goodreads или Letterboxd первым) + RabbitMQ + прогресс.
**Этап 3:** Публичные страницы + Year in Review.
**Этап 4:** Наблюдаемость/качество (метрики, DLQ, контрактные тесты).

---

## 7. Порядок контроля и приёмки

**Контроль:**

* Unit tests (Go/JS), интеграционные тесты (docker-compose).
* Контрактные тесты: proto (gRPC) и OpenAPI (REST BFF).
* Тесты импортов на эталонных файлах.
* Проверка RabbitMQ:

  * обработка сообщений с ack,
  * retry при ошибках,
  * попадание в DLQ при исчерпании попыток.

**Критерии приёмки MVP:**

* Регистрация/вход/refresh/выход работают.
* Можно добавить контент, видеть карточку с постером/обложкой.
* Можно менять статус/оценку/теги/заметки, фильтровать библиотеку.
* Импорт запускается асинхронно, прогресс отображается; при перезапуске сервисов обработка продолжается.
* Есть DLQ и базовая идемпотентность импорта.
* Проект поднимается одной командой через docker-compose.

---

## 8. Требования к документированию

* README: запуск, переменные окружения, миграции.
* Архитектура: схема сервисов, gRPC/REST, события RabbitMQ.
* Спеки API: OpenAPI для BFF, proto для сервисов.
* Док по импортам: поддерживаемые форматы, маппинг полей, ограничения.
* Описание ключей Redis и политики TTL.

---

## 9. Источники разработки

* Настоящее ТЗ.
* Документация: Next.js, Ant Design, Go, gRPC, PostgreSQL, Redis, RabbitMQ, Docker.

---